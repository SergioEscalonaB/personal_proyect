INTOCABLE
COB_CODIGO
CLI_CODIGO
TAR_CODIGO


---------------------------------------------
CARGAR COBRO
SELECT * FROM COBRO
-Carga todos los cobros del sistema

---------------------------------------------
CARGAR LOS CLIENTES DE UN COBRO
SELECT * FROM CLIENTES
where COB_CODIGO = "Yayo"
-Reemplazar lo que esta en comilla

---------------------------------------------

---------------------------------------------
OBTENIDENDO TARJETAS QUE NO ESTAN EN 0
ESTAN SON LAS QUE SE MUESTRAN EN EL COBRO PARA PODERLE HACER LOS ABONOS
(LAS 81 tarjetas, es largo porque si la tarjeta es nueva no tiene descripción)

SELECT C.CLI_CODIGO, C.CLI_NOMBRE, C.CLI_CALLE, C.COB_CODIGO, C.ESTADO, T.TAR_CODIGO, T.TAR_VALOR, T.TAR_CUOTA, T.TAR_FECHA, T.ITEN, T.ESTADO, T.TIEMPO, T.FP
FROM CLIENTES C
INNER JOIN TARGETA T
    ON C.CLI_CODIGO = T.CLI_CODIGO

LEFT JOIN (
    SELECT TAR_CODIGO, DES_RESTA
    FROM (
        SELECT 
            TAR_CODIGO,
            DES_RESTA,
            ROW_NUMBER() OVER (PARTITION BY TAR_CODIGO ORDER BY DES_FECHA DESC) AS rn,
            MAX(CASE WHEN DES_RESTA = 0 THEN 1 ELSE 0 END)
                OVER (PARTITION BY TAR_CODIGO) AS tuvo_cero
        FROM DESCRIPCION
    ) X
    WHERE rn = 1
      AND tuvo_cero = 0
) D ON T.TAR_CODIGO = D.TAR_CODIGO

WHERE T.ESTADO = 'ACTIVA'
  AND C.COB_CODIGO = 'Yayo'
  -- esta línea permite tarjetas nuevas SIN descripción
  AND (D.TAR_CODIGO IS NOT NULL OR NOT EXISTS (
        SELECT 1 
        FROM DESCRIPCION D2 
        WHERE D2.TAR_CODIGO = T.TAR_CODIGO
      ))

ORDER BY CAST(T.ITEN AS SIGNED);

-- ESTA ES LA FUNCION PARA MANERAR LA NEVEGACION
LIMIT 1 OFFSET 0; 
--primero (aca es donde manejamos LA NAVEGACION)

-----------------------------------------
CONTAR CUANTAS TARJETAS (clientes) HAY EN CADA COBRO

SELECT COUNT(*) as total
FROM CLIENTES C
INNER JOIN TARGETA T
    ON C.CLI_CODIGO = T.CLI_CODIGO

LEFT JOIN (
    SELECT TAR_CODIGO, DES_RESTA
    FROM (
        SELECT 
            TAR_CODIGO,
            DES_RESTA,
            ROW_NUMBER() OVER (PARTITION BY TAR_CODIGO ORDER BY DES_FECHA DESC) AS rn,
            MAX(CASE WHEN DES_RESTA = 0 THEN 1 ELSE 0 END)
                OVER (PARTITION BY TAR_CODIGO) AS tuvo_cero
        FROM DESCRIPCION
    ) X
    WHERE rn = 1
      AND tuvo_cero = 0
) D ON T.TAR_CODIGO = D.TAR_CODIGO

WHERE T.ESTADO = 'ACTIVA'
  AND C.COB_CODIGO = 'Yayo'
  -- esta línea permite tarjetas nuevas SIN descripción
  AND (D.TAR_CODIGO IS NOT NULL OR NOT EXISTS (
        SELECT 1 
        FROM DESCRIPCION D2 
        WHERE D2.TAR_CODIGO = T.TAR_CODIGO
      ))


---------------------------------------------
OBTENIENDO LA DESCRIPCION DE CADA TARJETA DE LOS CLIENTES ACTIVAS (el registro de abonos)

SELECT C.CLI_CODIGO, CLI_NOMBRE, T.TAR_CODIGO, T.TAR_FECHA, T.TAR_VALOR,D.FECHA_ACT, D.DES_FECHA, D.DES_ABONO, D.DES_RESTA 
FROM CLIENTES C
RIGHT JOIN TARGETA T
ON C.CLI_CODIGO = T.CLI_CODIGO
RIGHT JOIN DESCRIPCION D
ON T.TAR_CODIGO = D.TAR_CODIGO
WHERE D.TAR_CODIGO = "Yayo137"
ORDER BY C.CLI_CODIGO, TAR_FECHA, CAST(DES_RESTA AS SIGNED) DESC;

 SELECT 
      C.CLI_CODIGO, 
      C.CLI_NOMBRE, 
      T.TAR_CODIGO, 
      T.TAR_FECHA, 
      T.TAR_VALOR,
      D.FECHA_ACT, 
      D.DES_FECHA, 
      D.DES_ABONO, 
      D.DES_RESTA 
    FROM DESCRIPCION D
    INNER JOIN TARGETA T ON D.TAR_CODIGO = T.TAR_CODIGO
    INNER JOIN CLIENTES C ON T.CLI_CODIGO = C.CLI_CODIGO
    WHERE D.TAR_CODIGO = 'Yayo137'
    ORDER BY C.CLI_CODIGO, TAR_FECHA, CAST(DES_RESTA AS SIGNED) DESC;

---------------------------------------------
MUESTRA UNICAMENTE LA FILA DEL ULTIMO ABONO DEL CLIENTE, ESTO SERVIRIA PARA SABER EL SALDO PENDIENTE

SELECT C.CLI_CODIGO, CLI_NOMBRE, T.TAR_CODIGO, T.TAR_FECHA,
       T.TAR_VALOR, D.FECHA_ACT, D.DES_FECHA, D.DES_ABONO, D.DES_RESTA
FROM CLIENTES C
INNER JOIN TARGETA T ON C.CLI_CODIGO = T.CLI_CODIGO
INNER JOIN DESCRIPCION D ON T.TAR_CODIGO = D.TAR_CODIGO
WHERE D.TAR_CODIGO = 'Yayo137'
ORDER BY C.CLI_CODIGO, TAR_FECHA, CAST(DES_RESTA AS INTEGER) DESC
LIMIT 1
OFFSET (
    SELECT COUNT(*) - 1
    FROM DESCRIPCION
    WHERE TAR_CODIGO = 'Yayo137'
);
---------------------------------------------

AUMENTAMOS 1 A LOS ITEN - con esto podemos ya modificar lo del orden de las tarjetas, el iten

UPDATE TARGETA 
SET ITEN = ITEN - 1 -- aumento
WHERE TAR_CODIGO IN (
    SELECT T.TAR_CODIGO
    FROM TARGETA T
    INNER JOIN CLIENTES C ON T.CLI_CODIGO = C.CLI_CODIGO
    WHERE C.COB_CODIGO = "Yayo" 
    AND CAST(T.ITEN AS DECIMAL) >= 2
);


---------------------------------------------
ESTE SQL ES PARA VER LO DEL ORDEN DEL ITEN Y SI SE ESTABA CREANDO (Hay que colocar descripción o no carga la nueva)

SELECT C.CLI_CODIGO, CLI_NOMBRE, T.TAR_CODIGO, T.TAR_FECHA, T.TAR_VALOR,D.FECHA_ACT, D.DES_FECHA, D.DES_ABONO, D.DES_RESTA, T.ITEN 
FROM CLIENTES C
INNER JOIN TARGETA T
ON C.CLI_CODIGO = T.CLI_CODIGO
RIGHT JOIN DESCRIPCION D
ON T.TAR_CODIGO = D.TAR_CODIGO
WHERE C.COB_CODIGO = "Hernan"
GROUP BY C.CLI_NOMBRE
ORDER BY CAST(T.ITEN AS SIGNED),C.CLI_CODIGO, TAR_FECHA, CAST(DES_RESTA AS SIGNED) DESC

-- Creando
INSERT INTO CLIENTES (CLI_CODIGO, CLI_NOMBRE, COB_CODIGO) VALUES ('1010', 'Sergio Prueba', 'Hernan');

INSERT INTO TARGETA (CLI_CODIGO, TAR_CODIGO, ESTADO, TAR_FECHA, TAR_VALOR, ITEN)
VALUES ('1010', 'Hernan99', 'ACTIVA', '26-10-26', 150000, 5);

INSERT INTO DESCRIPCION (TAR_CODIGO, FECHA_ACT, DES_FECHA, DES_ABONO, DES_RESTA)
VALUES ('Hernan99', '26-oct-26->30', '01-nov-26', 30000, 120000);

-- Borrando
DELETE FROM DESCRIPCION 
WHERE TAR_CODIGO = 'Hernan99';

DELETE FROM TARGETA 
WHERE TAR_CODIGO = 'Hernan99';

DELETE FROM CLIENTES 
WHERE CLI_CODIGO = '1010'
AND NOT EXISTS (
    SELECT 1 FROM TARGETA WHERE CLI_CODIGO = '1010'
);
---------------------------------------------
ORDENANDO LOS ITEN TAL CUAL PERO CON NUMEROS ENTEROS, además se corrigiendo lo del estado activo de las tarjetas y a las que ya está
inactivas se les coloco el iten null para evitar tener enredo con los datos
Esto podría ser una opción si como enrutar / organizar tarjetas

-- Paso 1: Marcar como INACTIVAS y poner ITEN = NULL a las que NO cumplen la condición
UPDATE TARGETA
SET ESTADO = 'INACTIVA', ITEN = NULL
WHERE TAR_CODIGO IN (
    SELECT T.TAR_CODIGO
    FROM TARGETA T
    INNER JOIN CLIENTES C ON T.CLI_CODIGO = C.CLI_CODIGO
    WHERE C.COB_CODIGO = 'Yayo'
    AND T.ESTADO = 'ACTIVA'
    AND T.TAR_CODIGO NOT IN (
        -- Esta es la subquery de las tarjetas que SÍ deben estar activas
        SELECT T2.TAR_CODIGO
        FROM CLIENTES C2
        INNER JOIN TARGETA T2 ON C2.CLI_CODIGO = T2.CLI_CODIGO
        LEFT JOIN (
            SELECT TAR_CODIGO, DES_RESTA
            FROM (
                SELECT 
                    TAR_CODIGO,
                    DES_RESTA,
                    ROW_NUMBER() OVER (PARTITION BY TAR_CODIGO ORDER BY DES_FECHA DESC) AS rn,
                    MAX(CASE WHEN DES_RESTA = 0 THEN 1 ELSE 0 END)
                        OVER (PARTITION BY TAR_CODIGO) AS tuvo_cero
                FROM DESCRIPCION
            ) X
            WHERE rn = 1 AND tuvo_cero = 0
        ) D ON T2.TAR_CODIGO = D.TAR_CODIGO
        WHERE T2.ESTADO = 'ACTIVA'
          AND C2.COB_CODIGO = 'Yayo'
          AND (D.TAR_CODIGO IS NOT NULL OR NOT EXISTS (
                SELECT 1 FROM DESCRIPCION D2 WHERE D2.TAR_CODIGO = T2.TAR_CODIGO
              ))
    )
);

-- Paso 2: Renumerar solo las ACTIVAS que cumplen la condición
CREATE TEMP TABLE temp_iten AS
SELECT T.TAR_CODIGO, ROW_NUMBER() OVER (ORDER BY CAST(T.ITEN AS REAL)) as nuevo_iten
FROM CLIENTES C
INNER JOIN TARGETA T ON C.CLI_CODIGO = T.CLI_CODIGO
LEFT JOIN (
    SELECT TAR_CODIGO, DES_RESTA
    FROM (
        SELECT 
            TAR_CODIGO,
            DES_RESTA,
            ROW_NUMBER() OVER (PARTITION BY TAR_CODIGO ORDER BY DES_FECHA DESC) AS rn,
            MAX(CASE WHEN DES_RESTA = 0 THEN 1 ELSE 0 END)
                OVER (PARTITION BY TAR_CODIGO) AS tuvo_cero
        FROM DESCRIPCION
    ) X
    WHERE rn = 1 AND tuvo_cero = 0
) D ON T.TAR_CODIGO = D.TAR_CODIGO
WHERE T.ESTADO = 'ACTIVA'
  AND C.COB_CODIGO = 'Yayo'
  AND (D.TAR_CODIGO IS NOT NULL OR NOT EXISTS (
        SELECT 1 FROM DESCRIPCION D2 WHERE D2.TAR_CODIGO = T.TAR_CODIGO
      ));

-- Paso 3: Actualizar con los nuevos ITEN consecutivos
UPDATE TARGETA
SET ITEN = (SELECT nuevo_iten FROM temp_iten WHERE temp_iten.TAR_CODIGO = TARGETA.TAR_CODIGO)
WHERE TAR_CODIGO IN (SELECT TAR_CODIGO FROM temp_iten);

-- Paso 4: Limpiar
DROP TABLE temp_iten;

---------------------------------------------
NUEVO CLIENTE CON TARJETA

-- 1. Insertar el cliente
INSERT INTO CLIENTES (CLI_CODIGO, CLI_NOMBRE, CLI_CALLE, COB_CODIGO, ESTADO)
VALUES ('1010', 'Sergio Prueba', '315226', 'Yayo', 'ACTIVO');

-- 2. Insertar la tarjeta con el siguiente número
INSERT INTO TARGETA (TAR_CODIGO, CLI_CODIGO, TAR_VALOR, TAR_CUOTA, TAR_FECHA, ITEN, ESTADO, TIEMPO, FP)
SELECT 
    'Yayo' || (COALESCE(MAX(CAST(SUBSTR(TAR_CODIGO, LENGTH('Yayo') + 1) AS INTEGER)), 0) + 1), --Buscar ultimo tar_codigo
    '1010', -- Cli_codigo
    '500000', -- Tar_valor
    '50000', -- Tar_cuota
    '04-02-26', --Tar_fecha
    '5', --Iten
    'ACTIVA', --Estado
    '30', --Tiempo
    'S' --FP
FROM TARGETA 
WHERE TAR_CODIGO LIKE 'Yayo%';

----- ver el tar_codigo mas alto
-- Ver el TAR_CODIGO más alto para 'Yayo'
SELECT TAR_CODIGO 
FROM TARGETA 
WHERE TAR_CODIGO LIKE 'Yayo%'
ORDER BY CAST(SUBSTRING(TAR_CODIGO, 5) AS UNSIGNED) DESC
LIMIT 1;

----- eliminar
DELETE FROM TARGETA WHERE CLI_CODIGO = '1010';
DELETE FROM CLIENTES WHERE CLI_CODIGO = '1010';
